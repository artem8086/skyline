// SPDX-License-Identifier: MPL-2.0
// Copyright Â© 2021 Skyline Team and Contributors (https://github.com/skyline-emu/)

#include <common/trace.h>
#include <kernel/types/KProcess.h>
#include "address_space.h"

#define MAP_MEMBER(returnType) template<typename VaType, VaType UnmappedVa, typename PaType, PaType UnmappedPa, bool PaContigSplit, size_t AddressSpaceBits> requires AddressSpaceValid<VaType, AddressSpaceBits> returnType FlatAddressSpaceMap<VaType, UnmappedVa, PaType, UnmappedPa, PaContigSplit, AddressSpaceBits>

#define MM_MEMBER(returnType) template<typename VaType, VaType UnmappedVa, size_t AddressSpaceBits> requires AddressSpaceValid<VaType, AddressSpaceBits> returnType FlatMemoryManager<VaType, UnmappedVa, AddressSpaceBits>

#define ALLOC_MEMBER(returnType) template<typename VaType, VaType UnmappedVa, size_t AddressSpaceBits> requires AddressSpaceValid<VaType, AddressSpaceBits> returnType FlatAllocator<VaType, UnmappedVa, AddressSpaceBits>

namespace skyline {
    MAP_MEMBER()::FlatAddressSpaceMap(VaType pVaLimit) : vaLimit(pVaLimit) {
        if (pVaLimit > VaMaximum)
            throw exception("Invalid VA limit!");
    }

    MAP_MEMBER(void)::MapLocked(VaType virt, PaType phys, VaType size, bool flag) {
        TRACE_EVENT("containers", "FlatAddressSpaceMap::Map");

        VaType virtEnd{virt + size};

        if (virtEnd > vaLimit)
            throw exception("Trying to map a block past the VA limit!");

        auto blockEndSuccessor{std::lower_bound(blocks.begin(), blocks.end(), virtEnd)};
        if (blockEndSuccessor == blocks.begin())
            throw exception("Unexpected Memory Manager state!");

        auto blockEndPredecessor{std::prev(blockEndSuccessor)};

        if (blockEndSuccessor != blocks.end()) {
            // We have blocks in front of us, if one is directly in front then we don't have to add a tail
            if (blockEndSuccessor->virt != virtEnd) {
                PaType tailPhys{[&]() -> PaType {
                    if (!PaContigSplit || blockEndPredecessor->Unmapped())
                        return blockEndPredecessor->phys; // Always propagate unmapped regions
                    else
                        return blockEndPredecessor->phys + virtEnd - blockEndPredecessor->virt;
                }()};

                if (blockEndPredecessor->virt >= virt) {
                    // If this block's start would be overlapped by the map then reuse it as a tail block
                    blockEndPredecessor->virt = virtEnd;
                    blockEndPredecessor->phys = tailPhys;
                    blockEndPredecessor->flag = blockEndPredecessor->flag;
                } else {
                    // Else insert a new one and we're done
                    blocks.insert(blockEndSuccessor, {Block(virt, phys, flag), Block(virtEnd, tailPhys, blockEndPredecessor->flag)});
                    return;
                }
            }
        } else {
            // blockEndPredecessor will always be unmapped as blocks has to be terminated by an unmapped chunk
            if (blockEndPredecessor != blocks.begin() && blockEndPredecessor->virt >= virt) {
                // Move the unmapped block start backwards
                blockEndPredecessor->virt = virtEnd;
            } else {
                // Else insert a new one and we're done
                blocks.insert(blockEndSuccessor, {Block(virt, phys, flag), Block(virtEnd, UnmappedPa, false)});
                return;
            }
        }

        auto blockStartSuccessor{blockEndPredecessor};

        // Walk the block vector to find the start successor as this is more efficient than another binary search in most scenarios
        while (std::prev(blockStartSuccessor)->virt >= virt)
            std::advance(blockStartSuccessor, -1);

        if (blockStartSuccessor->virt > virtEnd)
            throw exception("Unexpected Memory Manager state!");

        if (blockStartSuccessor->virt == virtEnd) {
            // We need to create a new block as there are none spare that we would overwrite
            blocks.insert(blockStartSuccessor, Block(virt, phys, flag));
            return;
        } else {
            blockStartSuccessor->virt = virt;
            blockStartSuccessor->phys = phys;
            blockStartSuccessor->flag = flag;

            // Erase overwritten blocks
            if (auto eraseStart{std::next(blockStartSuccessor)}; blockStartSuccessor != blockEndPredecessor) {
                if (eraseStart == blockEndPredecessor)
                    __builtin_trap();

                blocks.erase(eraseStart, blockEndPredecessor);
            }
        }
    }

    MAP_MEMBER(void)::UnmapLocked(VaType virt, VaType size) {
        TRACE_EVENT("containers", "FlatAddressSpaceMap::Unmap");

        VaType virtEnd{virt + size};

        if (virtEnd > vaLimit)
            throw exception("Trying to map a block past the VA limit!");

        auto blockEndSuccessor{std::lower_bound(blocks.begin(), blocks.end(), virtEnd)};
        if (blockEndSuccessor == blocks.begin())
            throw exception("Unexpected Memory Manager state!");

        auto blockEndPredecessor{std::prev(blockEndSuccessor)};

        auto walkBackToPredecessor{[&](auto iter) {
            while (iter->virt >= virt)
                std::advance(iter, -1);

            return iter;
        }};

        auto eraseBlocksWithEndUnmapped{[&] (auto unmappedEnd) {
            auto blockStartPredecessor{walkBackToPredecessor(unmappedEnd)};
            auto blockStartSuccessor{std::next(blockStartPredecessor)};

            auto eraseEnd{[&]() {
                if (blockStartPredecessor->Unmapped()) {
                    // If the start predecessor is unmapped then we can erase everything in our region and be done
                    return std::next(unmappedEnd);
                } else {
                    // Else reuse the end predecessor as the start of our unmapped region then erase all up to it
                    unmappedEnd->virt = virt;
                    return unmappedEnd;
                }
            }()};

            // We can't have two unmapped regions after each other
            if (eraseEnd == blockStartSuccessor || (blockStartPredecessor->Unmapped() && eraseEnd->Unmapped()))
                throw exception("Unexpected Memory Manager state!");

            blocks.erase(blockStartSuccessor, eraseEnd);
        }};

        // We can avoid any splitting logic if these are the case
        if (blockEndPredecessor->Unmapped()) {
            if (blockEndPredecessor->virt > virt)
                eraseBlocksWithEndUnmapped(blockEndPredecessor);

            return; // The region is unmapped, bail out early
        } else if (blockEndSuccessor->virt == virtEnd && blockEndSuccessor->Unmapped()) {
            eraseBlocksWithEndUnmapped(blockEndSuccessor);
            return; // The region is unmapped here and doesn't need splitting, bail out early
        } else if (blockEndSuccessor == blocks.end()) {
            // This should never happen as the end should always follow an unmapped block
            throw exception("Unexpected Memory Manager state!");
        } else if (blockEndSuccessor->virt != virtEnd) {
            // If one block is directly in front then we don't have to add a tail
            
            // The previous block is mapped so we will need to add a tail with an offset
            PaType tailPhys{[&]() {
                if constexpr (PaContigSplit)
                    return blockEndPredecessor->phys + virtEnd - blockEndPredecessor->virt;
                else
                    return blockEndPredecessor->phys;
            }()};

            if (blockEndPredecessor->virt >= virt) {
                // If this block's start would be overlapped by the unmap then reuse it as a tail block
                blockEndPredecessor->virt = virtEnd;
                blockEndPredecessor->phys = tailPhys;
            } else {
                blocks.insert(blockEndSuccessor, {Block(virt, UnmappedPa, false), Block(virtEnd, tailPhys, blockEndPredecessor->flag)});
                return; // The previous block is mapped and ends bef
            }
        }

        // Walk the block vector to find the start predecessor as this is more efficient than another binary search in most scenarios
        auto blockStartPredecessor{walkBackToPredecessor(blockEndPredecessor)};
        auto blockStartSuccessor{std::next(blockStartPredecessor)};

        if (blockStartSuccessor->virt > virtEnd)
            throw exception("Unexpected Memory Manager state!");

        if (blockStartSuccessor->virt == virtEnd) {
            // There are no blocks between the start and the end that would let us skip inserting a new one for head

            // The previous block is may be unmapped, if so we don't need to insert any unmaps after it
            if (blockStartPredecessor->Mapped())
                blocks.insert(blockStartSuccessor, Block(virt, UnmappedPa, false));
        } else if (blockStartPredecessor->Unmapped()) {
            // If the previous block is unmapped
            blocks.erase(blockStartSuccessor, blockEndPredecessor);
        } else {
            // Add in the unmapped block header
            blockStartSuccessor->virt = virt;
            blockStartSuccessor->phys = UnmappedPa;

            // Erase overwritten blocks, skipping the first one as we have written the unmapped start block there
            if (auto eraseStart{std::next(blockStartSuccessor)}; blockStartSuccessor != blockEndPredecessor) {
                if (eraseStart == blockEndPredecessor)
                    __builtin_trap();

                blocks.erase(eraseStart, blockEndPredecessor);
            }
        }
    }

    MAP_MEMBER(void)::Map(VaType virt, PaType phys, VaType size, bool flag) {
        std::scoped_lock lock(blockMutex);
        MapLocked(virt, phys, size, flag);
    }

    MAP_MEMBER(std::vector<span<u8>>)::Translate(VaType virt, size_t size) {
        std::scoped_lock lock(blockMutex);

        auto block{std::upper_bound(blocks.begin(), blocks.end(), virt, [](const VaType address, const Block &block) -> bool {
            return address < block.virt;
        })};

        if (block == blocks.end() || block->Unmapped())
            throw exception("Failed to retrieve region in GPU address space: Address: 0x{:X}, Size: 0x{:X}", virt, size);

        block--;

        u64 blockStart{block->virt};
        u64 blockSize{(block + 1)->virt - blockStart};

        u64 blockOffset{virt - blockStart};
        u8 *source{reinterpret_cast<u8*>(block->phys + blockOffset)};
        u64 sourceSize{std::min(blockSize - blockOffset, size)};

        std::vector<span<u8>> mappings;
        while (size) {
            mappings.emplace_back(source, sourceSize);

            size -= sourceSize;
            if (size) {
                block += 2;
                if (block == blocks.end() || block->Unmapped())
                    throw exception("Failed to retrieve region in GPU address space: Address: 0x{:X}, Size: 0x{:X}", virt, size);

                blockStart = block->virt;
                blockSize = (block + 1)->virt - blockStart;
                source = reinterpret_cast<u8*>(block->phys);
                sourceSize = std::min(blockSize, size);
            }
        }
        return mappings;
    }

    MAP_MEMBER(void)::Unmap(VaType virt, VaType size) {
        std::scoped_lock lock(blockMutex);
        UnmapLocked(virt, size);
    }

    MM_MEMBER(void)::Read(u8 *destination, VaType virt, VaType size) {
        std::scoped_lock lock(this->blockMutex);

        TRACE_EVENT("containers", "FlatMemoryManager::Read");

        VaType virtEnd{virt + size};

        auto successor{std::upper_bound(this->blocks.begin(), this->blocks.end(), virt, [] (auto virt, const auto &block) {
            return virt < block.virt;
        })};

        auto predecessor{std::prev(successor)};

        u8 *blockPhys{predecessor->phys + (virt - predecessor->virt)};
        VaType blockReadSize{std::min(successor->virt - virt, size)};

        while (size) {
            if (predecessor->phys == nullptr) {
                if (predecessor->flag) // Sparse mapping
                    std::memset(destination, 0, blockReadSize);
                else
                    throw exception("Page fault at: 0x{:X}", predecessor->virt);
            } else {
                std::memcpy(destination, blockPhys, blockReadSize);
            }

            destination += blockReadSize;
            size -= blockReadSize;

            if (size) {
                predecessor = successor++;
                blockPhys = predecessor->phys;
                blockReadSize = std::min(successor->virt - predecessor->virt, size);
            }
        }
    }

    MM_MEMBER(void)::Write(VaType virt, u8 *source, VaType size) {
        std::scoped_lock lock(this->blockMutex);

        TRACE_EVENT("containers", "FlatMemoryManager::Write");

        VaType virtEnd{virt + size};

        auto successor{std::upper_bound(this->blocks.begin(), this->blocks.end(), virt, [] (auto virt, const auto &block) {
            return virt < block.virt;
        })};

        auto predecessor{std::prev(successor)};

        u8 *blockPhys{predecessor->phys + (virt - predecessor->virt)};
        VaType blockWriteSize{std::min(successor->virt - virt, size)};

        while (size) {
            if (predecessor->phys == nullptr) {
                if (!predecessor->flag) // Sparse mappings allow unmapped writes
                    throw exception("Page fault at: 0x{:X}", predecessor->virt);
            } else {
                std::memcpy(blockPhys, source, blockWriteSize);
            }

            source += blockWriteSize;
            size -= blockWriteSize;

            if (size) {
                predecessor = successor++;
                blockPhys = predecessor->phys;
                blockWriteSize = std::min(successor->virt - predecessor->virt, size);
            }
        }

    }

    ALLOC_MEMBER()::FlatAllocator(VaType vaStart, VaType vaLimit) : Base(vaLimit), vaStart(vaStart), currentLinearAllocEnd(vaStart) {}

    ALLOC_MEMBER(VaType)::Allocate(VaType size) {
        std::scoped_lock lock(this->blockMutex);

        TRACE_EVENT("containers", "FlatAllocator::Allocate");

        VaType allocStart{UnmappedVa};
        VaType allocEnd{currentLinearAllocEnd + size};

        if (allocEnd >= currentLinearAllocEnd && allocEnd <= this->vaLimit) {
            auto allocEndSuccessor{std::lower_bound(this->blocks.begin(), this->blocks.end(), allocEnd)};
            if (allocEndSuccessor == this->blocks.begin())
                throw exception("Unexpected allocator state!");

            auto allocEndPredecessor{std::prev(allocEndSuccessor)};
            if (allocEndPredecessor->virt <= currentLinearAllocEnd) {
                allocStart = currentLinearAllocEnd;
            } else {
                while (allocEndSuccessor != this->blocks.end()) {
                    if (allocEndSuccessor->virt - allocEndPredecessor->virt < size || allocEndPredecessor->Mapped() ) {
                        allocStart = allocEndPredecessor->virt;
                        break;
                    }

                    allocEndPredecessor = allocEndSuccessor++;

                    if (allocEndSuccessor == this->blocks.end()) {
                        allocEnd = allocEndPredecessor->virt + size;

                        if (allocEnd >= allocEndPredecessor->virt && allocEnd <= this->vaLimit)
                            allocStart = allocEndPredecessor->virt;
                    }
                }
            }
        }

        if (allocStart != UnmappedVa) {
            currentLinearAllocEnd = allocStart + size;
        } else {  // If linear allocation overflows the AS then find a gap
            if (this->blocks.size() <= 2)
                throw exception("Unexpected allocator state!");

            auto searchPredecessor{this->blocks.begin()};
            auto searchSuccessor{std::next(searchPredecessor)};

            while (searchSuccessor != this->blocks.end() &&
                (searchSuccessor->virt - searchPredecessor->virt < size || searchPredecessor->Mapped())) {
                searchPredecessor = searchSuccessor++;
            }

            if (searchSuccessor != this->blocks.end())
                allocStart = searchPredecessor->virt;
            else
                throw exception("Unexpected allocator state!");
        }


        this->MapLocked(allocStart, true, size);
        return allocStart;
    }

    ALLOC_MEMBER(void)::AllocateFixed(VaType virt, VaType size) {
        this->MapLocked(virt, true, size);
    }

    ALLOC_MEMBER(void)::Free(VaType virt, VaType size) {
        this->UnmapLocked(virt, size);
    }
}
